# С чего начать проект

Итак, у вас есть команда и техническое задание. Вы изучили все макеты и документацию. С чего начать работу?

В реальных проектах процессом разработки обычно управляет проджект-менеджер. Он владеет всей информацией о проекте, знает, как организовать команду и расставить приоритеты задачам. На нашем курсе эту роль выполняет наставник, он поможет вам начать работу.

Перед разработкой приложения вам предстоит запланировать задачи:

1. **Декомпозируйте проект.** Чтобы разрабатывать приложение одновременно всей командой, важно разбить работу над ним на мелкие подзадачи. Так будет легче отслеживать их выполнение, вы сможете чаще отправлять проект на ревью и скорее исправлять ошибки. Следуйте рекомендациям по декомпозиции из техзадания.
2. **Создайте задачи в таск-трекере.** Таск-трекер помогает следить за прогрессом и понимать, кто в команде над какой задачей работает. Для этих целей при работе над дипломным проектом вы будете  использовать GitHub.
3. **Приоритизируйте задачи.** Чтобы настроить взаимодействие в команде, важно определиться, в каком порядке реализовывать задачи. Если несколько разработчиков одновременно работают над связанными задачами, могут появиться сложные конфликты слияния веток и ошибки. Встречаются задачи, которые зависят друг от друга: например, нельзя реализовать логику выполнения поисковых запросов с параметрами фильтрации, пока не реализовали логику фильтра. Приоритеты важно учитывать и с этой точки зрения.
4. **Распределите задачи внутри команды.** При детальной декомпозиции распределиться можно так, что все поучаствуют в реализации каждой из функциональных возможностей. Чтобы во время работы над проектом все смогли проверить свои способности, каждому стоит взять по отдельной фиче и заниматься всеми слоями архитектуры каждой из них.
5. **Оценивайте время.** Очень важный навык Android-разработчика и разработчицы — умение корректно оценивать, сколько времени займёт выполнение задачи. Вначале это может быть сложно, но с опытом  оценивать становится проще, а оценки будут точнее.
   
Попробуйте представить, сколько времени вы потратите на задачу, которую берёте в работу. Запишите эту предположительную оценку задачи, а затем фиксируйте, сколько времени у вас реально на неё уходит. Когда задача готова, сравните предполагаемое и фактическое время выполнения. Здесь полезно поразмышлять о том, что повлияло на сроки: выводы помогут оценить время в следующий раз точнее. 

6. **Задавайте вопросы.** Проверьте, полностью ли понимаете, каким должен быть результат вашей задачи? Если есть вопросы, и вы не смогли найти ответ в техническом задании, задайте их наставнику. Вы учитесь — совершенно нормально не понимать что-то или сомневаться.
7. **Работайте с репозиторием.** Перед тем, как писать код, сделайте общий проект для команды. Мы создали для вас [репозиторий с шаблоном дипломного проекта](https://github.com/Yandex-Practicum/practicum-android-diploma). Он содержит структуру пакетов для чистой архитектуры и базовую настройку CI на основе [Github Action](https://github.com/features/actions), однако в проекте нет никакой логики, связанной с дипломным приложением. Форкните этот проект в репозиторий, к которому будет иметь доступ вся команда.
Дальше внимательно прочитайте `README.md` созданного проекта и выполните все указания из раздела «Предварительная настройка проекта». В конце создайте основные ветки (`main` и `develop`). От ветки `develop` каждый может создать ветку с названием своей задачи и приступить к написанию кода:

1️⃣ По мере выполнения работы в отдельных ветках вы постепенно мёрджите их в develop, не забывая перед объединением проводить друг другу код-ревью.

2️⃣ Когда ваша команда будет готова отдать первую часть работы над дипломным проектом на проверку, создайте от develop новую ветку под названием `iteration_1_review`.

3️⃣ Создаёте PR от ветки iteration_1_review в main, и **ваш лид** сдаёт работу на проверку. Пока работа на ревью, вы можете продолжать работу над другими задачами.

4️⃣ Когда получите фидбэк, можете мёрджить ветку iteration_1_review в main. Не забудьте обсудить и разобрать ошибки.

5️⃣ Чтобы ваши исправления не пропали, после того, как вы смёрджили iteration_1_review в main, вы должны смёрджить main в develop. В этом случае в main находится код всей первой итерации, который уже точно поревьювлен и исправлен, а в develop тоже есть исправленный код плюс код от уже новых доделанных задач.

        Так завершается первая итерация. Когда начнётся вторая итерация в 26 спринте, делаем всё аналогично, но создаём другую ветку — iteration_2_review. 

Вот небольшая иллюстрация, которая может вам правильно работать с ветками:


![image](https://pictures.s3.yandex.net:443/resources/skhema_main_update_1695641984.png)

Вот и всё. Вы готовы к своему финальному заданию. Работайте сообща, советуйтесь друг с другом, консультируйтесь с наставником и у вас всё обязательно получится!

## Подсказки

В профессиональной деятельности Android-разработчику часто приходится сталкиваться с чем-то новым в решении задач. Даже опытные специалисты продолжают учиться, чтобы использовать новые инструменты или узнавать неизведанные аспекты старого подхода. А умение искать и находить решение — одна из важнейших суперспособностей разработчиков и разработчиц.

В дипломном проекте для решения некоторых задач вам предстоит освоить кое-что новое, о чём мы не рассказывали в рамках курса. Вы можете подготовиться к реальной работе и поискать решение самостоятельно — в поисковых системах или документации. Если у вас не получится или потребуется много времени, можете использовать раздел с подсказками.

### Декомпозиция

В ТЗ, как правило, нет технических деталей реализации функциональных возможностей. Но в этой части есть много работы, которую можно разделить на задачи и сделать прежде, чем переходить к непосредственной реализации самих фич. Например:

- **Подготовить Data-слой:** инициализировать Retrofit, конфигурировать базу данных с Room, реализовать интерфейсы NetworkClient, DatabaseClient и прочие ключевые классы, которые будут использоваться различными репозиториями приложения.
- **Подготовить Domain-слой:** проработать модели данных (пакет `domain.models`) и создать интерфейсы Repository и Interactor. Имея интерфейсы, уже можно работать над логикой взаимодействия между слоями архитектуры, не дожидаясь пока будет готова реализация этих интерфейсов.
- **Подключить необходимые библиотеки** к проекту.
- **Настроить DI:** создать и подключить Koin модули.
- **Настроить навигацию:** инициализировать граф навигации, создать необходимые Destination и Action. В рамках такой задачи можно создавать пустые фрагменты, которые затем вы и другие участники команды смогут наполнить необходимой логикой.

Другими словами, за выполнение сетевых запросов в проекте отвечает один компонент, но он нужен для реализации большинства задач, и сразу несколько разрабочиков не могут одновременно работать над его созданием. Поэтому необходимо позаботиться о нём отдельно и заранее: до того, как кто-то приступит к связанной с ним задаче. То же самое касается навигации — она пригодится сразу всем разработчикам, но одновременная работа над конфигурацией графа навигации приведёт к merge-конфликтам.


### Работа с API

Документация API у HeadHunter достаточно подробная. Базовые правила его использования описаны в [этом разделе](https://github.com/hhru/api/blob/master/docs/general.md).
Однако там и в других частях документации ждут некоторые понятия и новые подходы к работе с API, которые могут вызвать вопросы. Одна из таких особенностей — использование **User-Agent**.

**User-Agent**

В документации вы можете увидеть требование передавать в запросах заголовок `User-Agent`. Этот заголовок может содержать информацию о типе устройства, операционной системе, используемой версии приложения и другие детали. Получается что-то вроде визитной карточки вашего устройства.

В контексте клиент-серверной мобильной разработки User-Agent может быть полезен для:

- Адаптации контента: сервер выдаст разный контент или стиль отображения в зависимости от устройства или браузера клиента. Например, мобильная версия сайта может отличаться от полноценной версии для персональных компьютеров.
- Статистики и аналитики: разработчики и владельцы сайтов проанализируют данные о User-Agent, чтобы узнать, какие устройства, ОС или браузеры наиболее популярны среди их пользователей.
- Безопасности: если сервер заметит подозрительную активность с определенного User-Agent, он временно заблокирует или ограничит доступ этому агенту.
- Функциональных возможностей: некоторые функции сайта или приложения доступны только для определенных устройств или версий ОС. С помощью User-Agent сервер определит, поддерживает ли устройство пользователя эту функцию.

Другими словами, User-Agent — это способ для вашего устройства представить себя серверу, чтобы тот лучше понял, как ему обслуживать ваш запрос. Однако не каждый сервер требует передавать агент.

В случае с API HeadHunter подобный агент необходим для безопасности. Чтобы выполнять запросы к серверу, помимо заголовка с токеном авторизации, нужно добавить ещё один — HH-User-Agent. Этот агент должен содержать:

- Название приложения (именно то, которое вы указывали при подаче заявки на доступ к использованию API).
- Адрес электронной почты для обратной связи (можете указать адрес электронной почты как в учётной записи, от имени которой поддавали заявку).
И в сочетании с токеном авторизации такой заголовок будет выглядеть следующим образом:

```kotlin
@Headers("Authorization: Bearer YOUR_TOKEN",
        "HH-User-Agent: Application Name (name@example.com)")
@GET("/vacancies/{vacancy_id}")
suspend fun getVacancy(@Path("vacancy_id") id: String): Response
```

Такие же заголовки предстоит использовать во всех запросах, требующих авторизации.

**Параметры поисковых запросов**

Из описания формата запросов для поиска вакансий в [документации](https://api.hh.ru/openapi/redoc#tag/Poisk-vakansij/operation/get-vacancies) видно, что этот запрос может принимать большое количество параметров. Многие из этих параметров опциональны, но некоторые вам понадобятся, чтобы настроить фильтрацию поискового запроса (указание региона поиска, желаемого уровня ЗП и т. д.). Настройки фильтра тоже опциональны: например, пользователь может задать только регион поиска или просто поставить галочку «Не показывать без ЗП».

Ваша логика должна предусматривать передачу параметров в запрос в различных сочетаниях. В запросе нельзя передавать пустые значения параметров (сервер вернёт сообщение об ошибке), и если не указать какую-то из настроек фильтра, такой параметр вообще не передастся в запрос. Набор параметров для этого запроса должен формироваться автоматически, учитывая указанные настройки фильтрации.
Есть разные способы добиться этого для `GET` запросов, но самый простой — использование `QueryMap`.

**QueryMap**

Рассмотрим простой пример. Когда вы отправляете запрос на сервер, вы можете добавить параметры к этому запросу. Например, если хотите найти все кафе в городе, отправляете запрос с параметром `city`:

```kotlin
@GET("search/cafes")
suspend fun searchCafes(@Query("searchRequest") searchRequest: String,
                        @Query("city") city: String): List<Cafe>
```

Если хотите добавить ещё один параметр, например, чтобы искать кафе с учётом графика работы, то так будет выглядеть запрос с дополнительным параметром:

```kotlin
@GET("search/cafes")
suspend fun searchCafes(@Query("searchRequest") searchRequest: String,
                        @Query("city") city: String
                        @Query("openHours") openHours: String): List<Cafe>
```

И если запрос всегда выполняется с таким набором параметров, то, как правило, в методе интерфейса, описывающего API-запросы, достаточно использовать аннотацию `@Query`. Но если какие-то из параметров не обязательны, то вы можете использовать `@QueryMap`, а не создавать в интерфейсе методы со всеми возможными сочетаниями параметров. Такая аннотация позволяет передавать в метод запроса объект типа `Map`, где ключ — имя параметра, а значение — значение параметра:

```kotlin
@GET("search/cafes")
suspend fun searchCafes(@QueryMap options: Map<String, String>): List<Cafe>
```

Так вы сможете передавать в запрос только тот набор параметров, который необходим в конкретной ситуации, а Retrofit преобразует их в корректный `GET` запрос для вас. Подготовить параметры и вызвать метод можно следующим образом:

```kotlin
val options: HashMap<String, String> = HashMap()

options["searchRequest"] = searchRequest
if (city.isNotEmpty()) {
    options["city"] = city
}
if (openHours.isNotEmpty()) {
    options["openHours"] = openHours
}

cafeSearchService(options).execute()
```

Используя `QueryMap`, вы можете легко и гибко управлять параметрами запроса без необходимости менять сигнатуру вашего метода или добавлять множество отдельных аннотаций `@Query`.

**Работа со справочниками**

Чтобы реализовать настройки фильтрации поиска, вам понадобится выполнять запросы для получения списка [Отраслей компаний](https://api.hh.ru/openapi/redoc#tag/Obshie-spravochniki/operation/get-industries) и списка всех доступных [Регионов](https://github.com/hhru/api/blob/master/docs/areas.md). Данные запросы относятся к категории Справочников и имеют уровень доступа `anonymous`: для их выполнения не обязательно добавлять в заголовок токен авторизации или User-Agent.

Обратите внимание на структуру элемента списка регионов:

```json
{
    id: "",
    parent_id: "",
    name: "",
    areas: [ ... ]
}
```

- `id` — это идентификатор региона. Именно это значение нужно передавать в качестве параметра поискового запроса, чтобы поиск вакансий шёл только среди предложений из указанного региона.
- `parent_id` — если регион входит в состав другого региона (например, страны или области), то в данном поле будет идентификатор родительского региона. Если значение в этом поле равно `null`, значит, данный регион — страна, что поможет сформировать список стран для экрана с настройками фильтров поиска.
- `name` — содержит имя региона для отображения в списке и на экране выбранных настроек.
- `areas` — если регион — страна или область, то в его составе могут находиться другие субъекты и населённые пункты. К элементам массива `areas` относятся точно такие же элементы с полями `id`, `parent_id`, `name` и `areas`. Если массив `areas` пуст, данный регион — населённый пункт (город, село и т. д.). В качестве элементов списка регионов на экране настроек фильтров нужно использовать все субъекты (регионы, которые не являются странами, и у которых массив `areas` не пустой), а так же все населённые пункты, которые входят в состав субъектов (у которых массив `areas` пуст). Вам необходимо собрать все такие регионы в один список (тип данных у них будет одинаковый: они имеют одинаковые поля) и отсортировать по алфавиту.

Немного проще устроен справочник отраслей компаний. Он состоит из массива элементов следующего вида:

```json
{
    id: "",
    name: "",
    industries: [ ... ]
}
```

Это категории отраслей. А в массиве `industries` находятся уже более конкретные отрасли:

```json
{
    id: "",
    name: ""
}
```

Таким образом, список отраслей на экране настроек параметров фильтрации поиска должен состоять из отраслей высокого уровня и из всех элементов, входящих в массив `industries` каждого из них. Здесь тоже можно обойтись одним типом данных: просто у дочерних отраслей `industries` всегда будет `null`.

**Общие советы по использованию API**

В документации к каждому из запросов можно прочитать, какие параметры запросов и поля из ответов на эти запросы обязательны. Они помечены красным словом `required`. Может показаться, что помеченные поля обязательно должны присутствовать в ответе. Но на практике в ответе может не быть таких полей ответа на поисковый запрос и деталей вакансии `salary`, `address`, `contacts` и `key_skills` в объекте самой вакансии, а так же `logo` в объекте `employer`: важно быть готовым и ожидать, что сервер не пришлёт эти данные, тогда придётся обрабатывать их как `null`.

И не забывайте о том, что токен авторизации должен генерироваться только один раз. Если по какой-то причине его сгенерировали повторно, убедитесь, что вся команда получила новый токен.


### Основная логика приложения и UI

Структура вашего будущего приложения похожа на структуру знакомых Playlist Maker и приложения для поиска фильмов. Общий набор инструментов, которые вам предстоит использовать, остаётся прежним:

- Чистая архитектура с шаблоном MVVM (ViewModel и LiveData для связи UI со слоем данных).
- Retrofit для выполнения сетевых запросов.
- SharedPreference для сохранения параметров фильтрации и Room для хранения избранных вакансий.
- Корутины для асинхронных задач и многопоточности.
- Внедрение зависимостей (репозитории, интеракторы и ViewModel) при помощи Koin.
- Jetpack Navigation Component и BottomNavigationView для реализации навигации в приложении.

Если забыли, как пользоваться тем или иным инструментом, просто вернитесь к соответствующей части курса или исходному коду одного из проектов. Это совершенно нормально: даже опытные разработчики периодически подсматривают в старый код, чтобы освежить в памяти какие-то тонкости.

А сейчас разберёмся, какие особенности есть у приложения с вакансиями.

**Постраничная загрузка вакансий на экране поиска**

Весь этот экран и большая часть его логики аналогичны экрану поиска аудиотреков в Playlist Maker. Но есть одна деталь, которая делает задачу более интересной.

Речь идёт о подходе Paging (от английского page — «страница»), который называют «пейджингом» или «пагинацией». Вы могли его видеть в приложениях, которые по запросу показывают большое количество схожих элементов с текстами и иллюстрациями. Чтобы не подгружать их слишком долго и не тратить сразу много пользовательского трафика, API передают такие объёмные списки по частям.

Сервер, предоставляющий такую возможность, разбивает весь объём выдачи на несколько частей (страниц), и клиент вместо того, чтобы получать список результатов целиком, запрашивает его по частям, получая от сервера страницы одну за другой. Размер страницы (количество элементов в одной части выдачи) клиент, как правило, может указать при выполнении самого первого запроса. Выглядит это обычно так:

**ВИДЕО ИЛИ ГИФКА**

![video_or_gif](https://code.s3.yandex.net/Mobile/Android/%D0%92%D0%B8%D0%B4%D0%B5%D0%BE/paging.mp4)

Когда пользователь долистывает список элементов до конца, приложение выполняет запрос следующей страницы контента и показывает индикатор загрузки в нижней части экрана. Так может продолжаться, пока пользователь не дойдёт до самой последней страницы.
С точки зрения API, Paging можно реализовать совершенно по-разному, но в случае с запросами HeadHunter это логика состоит из следующих основных параметров:

- `per_page` — это параметр, который клиент передаёт в запросе (например, при поиске вакансий), чтобы уточнить, какой размер страницы он хочет получить в ответе от сервера. По ТЗ данного проекта, страница должна содержать 20 вакансий. Если этот параметр не передавать, сервер вернёт по 10 элементов в каждой странице.
- `pages` — это параметр, возвращаемый сервером. Он содержит количество страниц, на которое разбит весь объём результатов запроса. По этому значению можно определить, нужно ли запрашивать следующую страницу контента, или же пользователь находится на последней странице.
- `page` — этот параметр передаёт клиент, чтобы указать серверу, какую именно страницу он желает получить. Сервер в ответе использует параметр с таким же названием, чтобы указать, к какой именно странице относится переданный клиенту контент.

Оперируя этими параметрами, вы можете действовать так:

- Подготовьте метод выполнения поискового запроса: убедитесь, что он принимает все параметры для пагинации (или используйте `QueryMap`).
- Убедитесь, что в ваших DTO-классах есть поля `page` и `pages`.
- Создайте и реализуйте интерфейс Repository с методами для получения вакансий.
- Создайте и реализуйте в Presentation слой.
- В слое представления внутри ViewModel инициализируйте переменные для текущей страницы (`currentPage`), максимального числа страниц (`maxPages`) и списка загруженных элементов (`vacanciesList`).
- Создайте метод `searchVacancies()`, который проверит, не является ли `currentPage` последней страницей (сравнение с `maxPages`). Если не последняя, вызывать Interactor для загрузки данных.
- После получения новой порции вакансий необходимо добавить их в конец списка `vacanciesList` и увеличить `currentPage`.
- При прокрутке списка до конца сообщите ViewModel об этом, чтобы она выполнила метод `searchVacancies()`. Если выясняется, что текущая страница является последней, можно просто убрать индикатор загрузки.

В итоге алгоритм работы постраничной загрузки будет выглядеть следующим образом:

- Пользователь начинает поиск вакансий.
- Приложение вызывает `searchVacancies()` для загрузки первой страницы.
- При прокрутке до конца списка вызывается `searchVacancies()` для следующей страницы.
- Если достигнута последняя страница, то больше не делать запросы для следующих страниц.

Чтобы определить, что пользователь доскроллил список до последнего элемента списка, существуют различные способы. Например, можно установить OnScrollListener для RecyclerView и, в методе `onScrolled`, определять последний видимый элемент и направление скролла. Используя эти данные можно узнать, что пользователь долистал до конца:

```kotlin
binding.vacancies.addOnScrollListener(object : OnScrollListener() {
    override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
        super.onScrolled(recyclerView, dx, dy)

        if (dy > 0) {
            val pos = (binding.vacancies.layoutManager as LinearLayoutManager).findLastVisibleItemPosition()
            val itemsCount = vacancyAdapter.itemCount
            if (pos >= itemsCount-1) {
                viewModel.onLastItemReached()
            }
        }
    }
})
```

- Метод `onScrolled` вызывается каждый раз, когда список прокручивается.
- `if (dy > 0)`. `dy` — это разница между последней и текущей позицией прокрутки по вертикали. Если `dy` больше `0`, значит, пользователь прокручивает список вниз.
- `findLastVisibleItemPosition()` — этот метод возвращает позицию последнего видимого элемента в списке. Так мы можем понять, когда пользователь приблизился к концу списка.
- `if (pos >= itemsCount-1)` — если позиция последнего видимого элемента (`pos`) близка к общему количеству элементов в списке (`itemsCount`) минус один (потому что индексация начинается с `0`), значит, пользователь прокрутил список до самого конца.
- Когда все эти условия выполнены, вызывается метод ViewModel, чтобы запросить следующую страницу контента, если она есть. В свою очередь, UI, подписанный на LiveData и предоставляющий список найденных вакансий, отобразит индикатор загрузки в нижней части экрана, пока новая страница загружается.

Это один из самых простых способов, но он имеет побочный эффект: при проверке этих условий в методе `onScrolled()` метод `viewModel.onLastItemReached` может вызываться множество раз при получении новой порции элементов списка. Убедитесь, что ViewModel не выполняет лишние запросы одной и той же страницы. Для этого можно, например, добавить в ViewModel переменную `isNextPageLoading`, которая будет иметь значение `true` с момента запроса новой страница до её получения. Пока она имеет значение `true`, никакие запросы не должны выполняться. После получения новых элементов можно поменять значение на `false`.

**Экран настроек параметров фильтрации поисковых запросов**

С точки зрения Data- и Domain-слоя, главная особенность этой части приложения — возможность сохранять и читать настройки. Для этих целей отлично подходит SharedPreferences, потому что значения настроек достаточно просты:

- Реализуйте Storage класс в слое Data, который будет управлять сохранением, чтением и обновлением настроек.
- Для удобства работы с параметрами настроек удобно создать отдельный класс `FilterParameters`, поля которого сохранят текущие значения настроек. Сохранять и получать объект этого типа из SharedPreferences целиком можно при помощи Gson (как вы делали с историей поиска в приложении Playlist Maker).
- Создайте Repository и Interactor, которые обеспечат слою представления доступ к актуальным настройкам параметров фильтрации поиска и возможность обновления их значений.

Так, несмотря на то, что настройки фильтра состоят из нескольких экранов, вы сможете отслеживать изменения параметров и обновлять их, используя уже созданный интерактор, внедрив его как зависимость в ViewModel каждого из экранов.

С точки зрения UI, стоит обратить внимание на поиск по Странам, Регионам и Отраслям компаний. Важно, что запросы справочника не умеют искать по ключевым словам. Поэтому вам предстоит получить полный список регионов и отраслей, а поиск осуществлять локально.
Реализуется локальный поиск проще, чем звучит. Если он необходим только для визуального упрощения работы с большими списками, и за этим не скрыта сложная бизнес-логика, то его легко реализовать на уровне адаптера для RecyclerView, добавив в него, помимо списка `irems`, два дополнительных:

- `originalList` — хранится оригинальный список элементов,
- `filteredIList` — хранятся элементы списка, которые удовлетворяют поисковому запросу.

Логика работы с адаптером в этом случае модифицируется следующим образом:

```kotlin
private var items: MutableList<Item> = ArrayList<>()
private val originalList: MutableList<Item> = ArrayList<>()
private val filteredList: MutableList<Item> = ArrayList<>()

fun setItems(items: MutableList<Item>) {
    this.items = items
    notifyDataSetChanged()
    originalList.clear()
    originalList.addAll(items)
}

private fun updateDisplayList(updatedList: List<Item>) {
    items.clear()
    items.addAll(updatedList)
    notifyDataSetChanged()
}

fun filter(searchQuery: String?) {
    filteredList.clear()
    if (searchQuery.isNullOrEmpty()) {
        updateDisplayList(originalList)
    } else {
        for (item in originalList) {
            if (item.name.contains(searchQuery, true)) {
                filteredList.add(item)
            }
        }
        updateDisplayList(filteredList)
    }
}
```

- Все три списка содержат элементы одного и того же типа.
- Метод `setItems()` используется во фрагменте для установки элементов списка, полученных от ViewModel через LiveData (вместо `adapter.items = items`). В этом же методе все элементы так же помещаются в список `originaIList`, чтобы восстановить исходное состояние списка без обращения к ViewModel.
- `updateDisplayList()` используется для обновления списка элементов, которые будут видны пользователю. Для этого в списке `items` должны находиться только те элементы, которые, например, удовлетворяют поисковому запросу.
- Метод `filter()` вызывается из фрагмента при изменении текста в поле ввода поискового запроса. Если текст запроса пустой, в метод `updateDisplayList()` передаётся оригинальный набор элементов, который неизменно хранится в `originalList`. В противном случае, предварительно очищенный `filteredList` заполняется элементами, имена которых частично или полностью совпадают с текстом поискового запроса. После этого заполненный `filteredList` передаётся в метод `updateDisplayList()`.

Никаких других изменений в логику работы адаптера вносить не нужно.

Если же необходимо как-то дополнительно реагировать на результат локального поиска и избавить UI слой от такой логики, то можно перенести в ViewModel работу со списками `filteredList` и `originalList`, а также метод `filter()`, который вызовется из UI, если поменяют текста поискового запроса. Фрагмент, подписанный на изменение состояния списка элементов, просто обновит список `items` у адаптера, используя те элементы, которые вернёт ViewModel. В этом случае логика адаптера никак не изменится, и даже не нужен метод `updateDisplayData()`: можно, как и прежде, использовать `adapter.items = items`. Оригинальный список всегда будет у ViewModel, и он передастся адаптеру, если поисковый запрос окажется пустым.

**Экран подробностей о вакансии**

Данный экран не обладает сложной логикой: важно только справиться с вёрсткой, выбрать правильные данные из ответа от сервера и корректно отобразить их на экране.
Детали вакансии запрашиваются отдельным запросом, и каждый ответ содержит много информации. Стоит внимательно изучить документацию и использовать только то, что нужно по дизайну. Ещё важный момент: работодатели не всегда указывают полную информацию, в какой-то вакансии может не оказаться ключевых навыков или контактов. Учитывайте, что какие-то подзаголовки этого экрана могут отсутствовать.

При нажатии на кнопку «Поделиться» в правом верхнем углу вам необходимо, используя уже знакомый `Intent.ACTION_SEND`, отправить через выбранный пользователем мессенджер ссылку на вакансию на сайте HeadHunter. Эта ссылка в ответе от сервера находится в параметре `alternate_url`.

В разделе «Контакты» может присутствовать адрес электронной почты и/или телефонный номер. При нажатии на email нужно попросить систему открыть на смартфоне пользователя приложение для отправки электронных писем. Это можно сделать, используя Intent с `ACTION_SENDTO`:

```kotlin
Intent(Intent.ACTION_SENDTO).apply {
    data = Uri.parse("mailto:" + "email_address")
}
```

При нажатии на номер телефона пользователь должен выбрать приложение для звонков. Для этого используется `ACTION_DIAL`:

```kotlin
Intent(Intent.ACTION_DIAL).apply {
    data = Uri.parse("tel:" + "phone_number")
}
```

Главная особенность этого экрана — информация для раздела «Описание вакансии», которая находится в параметре ответа `description` и приходит от сервера в формате HTML.
**HTML** (HyperText Markup Language, «язык гипертекстовой разметки») — это язык разметки, который используется для создания структуры и оформления веб-страниц и документов в интернете. С его помощью можно определить, какие элементы окажутся на странице (текст, изображения, ссылки, формы и т.д.), и как они будут организованы относительно друг друга.

Простыми словами, HTML — это набор XML-тегов, которые говорят браузеру, как отображать содержимое страницы. Каждый тег описывает разные типы содержимого. Например:

- `<h1>` определяет заголовок первого уровня;
- `<p>` используется для абзацев текста;
- `<b>` делает текст «жирным»;
- `<i>` выделяет текст «курсивом».

Чтобы работодатели могли самостоятельно выделять какие-то части описания размещаемой вакансии платформа HeadHunter предоставляет им для подготовки описания простейший текстовый редактор с возможностями форматирования текста. Готовый отформатированный текст описания дальше преобразуется в HTML-формат, чтобы он выглядел одинаково в различных браузерах.
Поэтому, если вы посмотрите в текст описания вакансии в ответе от сервера, увидите упомянутые выше теги:

```html
<h1>Мы ищем нового коллегу в колл-центр!</h1> <p>Контракт временный на 1 год с пролонгацией.</p>
```

Но если вы поместите такой текст в TextView, он отобразится на экране вместе со всеми тегами и будет выглядеть неаккуратно.
К счастью, в стандартном наборе Android SDK есть класс `Html` со статическим методом, который позволяяет отформатировать текст в HTML-формате и привести его к виду для TextView. Вот что нужно для этого сделать:

```kotlin
descriptionTextView.setText(Html.fromHtml(description, Html.FROM_HTML_MODE_COMPACT))
```

Важно устанавливать текст именно при помощи метода `setText()`. Метод `Html.fromHtml()` вернёт текст в отформатированном виде: в качестве первого параметра метода необходимо передать текст в HTML-формате, а в качестве второго — режим форматирования `Html.FROM_HTML_MODE_COMPACT`.
В результате текст описания отобразится на экране в отформатированном виде, со всеми заголовками и выделениями: в том виде, в котором задумывал работодатель.

**Добавление вакансий в Избранное**

С подобной задачей вы уже сталкивались, когда работали над Избранным в приложении Playlist Maker.

- Сконфигурируйте базу данных, чтобы хранить всю информацию для отображения деталей на экране вакансии без подключения к интернету. Исключение составляет логотип компании (если нет интернета, можно показывать плейсхолдер).
- Опишите методы DAO-интерфейса, которые позволят добавлять и удалять вакансии, а так же возвращать список всех вакансий, добавленных в Избранное.
- Обратите внимание, что на экране Избранное для отображения элементов списка требуется не так много информации. Более того, этот список идентичен списку результатов поиска. И чтобы иметь возможность переиспользовать Adapter и ViewHolder, вы можете реализовать на уровне репозитория конвертер, который из списка вакансий с подробной информацией сформирует список упрощённых элементов для Избранного.

Убедитесь в том, что кнопка добавления в Избранное в правом верхнем углу экрана находится в корректном состоянии, когда пользователь попадает на экран с подробностями о вакансии.


